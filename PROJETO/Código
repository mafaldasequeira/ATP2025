import FreeSimpleGUI as sg
import random
import numpy as np
import json
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import io
import sys

# Configurar tema do PySimpleGUI
sg.theme('LightBlue3')

#Atribuição de pulseiras aos doentes
def atribuir_pulseira():
    cores = ["verde", "amarela", "vermelha"]   # distribuição das pulseiras
    pesos_pulseiras = [0.7, 0.2, 0.1]
    return random.choices(cores, weights=pesos_pulseiras, k=1)[0]

#Atribuição de especialidades aos doentes
especialidades = [
    "Medicina Geral",
    "Ortopedia",
    "Gastroenterologia",
    "Cardiologia",
    "Neurologia",
    "Psiquiatria"
]

pesos = [
    0.35,  # Medicina Geral 
    0.20,  # Ortopedia
    0.15,  # Gastroenterologia
    0.15,  # Cardiologia
    0.10,  # Neurologia
    0.05   # Psiquiatria 
]

pesos_medicos= [
    0.30,  # Medicina Geral 
    0.20,  # Ortopedia
    0.15,  # Gastroenterologia
    0.20,  # Cardiologia
    0.10,  # Neurologia
    0.05   # Psiquiatria 
]

def atribuir_especialidade():
    return random.choices(especialidades, weights=pesos, k=1)[0]

# Funções de manipulação de eventos
# Evento = (tempo: Float, tipo: String, doente: String)
def e_tempo(e):
    return e[0]

def e_tipo(e):
    return e[1]

def e_doente(e):   #é o id do doente
    return e[2]

# Funções de manipulação para a Queue de Eventos
# queueEventos = [Evento]
def procuraPosQueue(q, t): # t: valor que queremos inserir em q
    i = 0
    while i < len(q) and t > q[i][0]: # compara o novo tempo t com o que está na posição i
        i+=1 # se t> q[i][0], o contador passa para 1; se t<q[i][0], entao t estará entre esses dois valores
    return i # retorna a nova posiçao do t

def enqueue(q, e): # adiciona novo evento a fila
    pos = procuraPosQueue(q, e[0]) # vai encontrar a posiçao do evento na fila e guarda na variavel temporaria
    return q[:pos] + [e] + q[pos:] # coloca o evente no meio

def dequeue(q): # remove
    e = q[0]
    q = q[1:]
    return e, q # devolve elemento retirado e lista atualizada

# Funções de manipulação de médicos
# Médico = [id: String, ocupado: Boolean, doente_corrente: String, total_tempo_ocupado: Float, inicio_ultima_consulta: Float, Especialidade: String]
def m_id(e):
    return e[0]

def m_ocupado(e):
    return e[1]

def mOcupa(m): # inverte estado de ocupaçao
    m[1] = not m[1] 
    return m

def m_doente_corrente(e):
    return e[2]

def mDoenteCorrente(m, d): 
    m[2] = d # define o doente d como o paciente atual
    return m

def m_total_tempo_ocupado(e):
    return e[3]

def mTempoOcupado(m, t):
    m[3] = t # atualiza o contador tempo com o valor tempo
    return m

def m_inicio_ultima_consulta(e):
    return e[4]

def mInicioConsulta(m, t):
    m[4] = t # atualiza o horario com o valor t
    return m 

def m_especialidade(e):
    return e[5]

# Funções de manipulação de emfermeiros
# Enfermeiro = [id: String, ocupado: Boolean, doente_corrente: String, total_tempo_ocupado: Float, inicio_ultima_triagem: Float]
def enf_id(e):
    return e[0]         

def enf_ocupado(e):
    return e[1] 

def enfOcupa(enf):
    enf[1] = not enf[1]
    return enf

def enf_doente_corrente(e):
    return e[2]

def enfDoenteCorrente(enf, d):
    enf[2] = d
    return enf

def enf_total_tempo_ocupado(e):
    return e[3]

def enfTempoOcupado(enf, t):
    enf[3] = t
    return enf

def enf_inicio_ultima_triagem(e):
    return e[4]

def enfInicioTriagem(enf, t):
    enf[4] = t
    return enf


# Utilização das distribuições para gerar chegadas e durações das consultas
def gera_intervalo_tempo_chegada(lmbda): # usa a distrib expo para calcular quanto tempo falta ate chegar o proximo doente, baseando se numa taxa lmbda
    return np.random.exponential(1 / lmbda)

def gera_tempo_triagem(TEMPO_MEDIO_TRIAGEM): # gera uma duraçao aleatoria usando uma distrib expo
    return np.random.exponential(TEMPO_MEDIO_TRIAGEM)

def gera_tempo_consulta(DISTRIBUICAO_TEMPO_CONSULTA,TEMPO_MEDIO_CONSULTA): # gera duraçao aleatoria de consulta
    if DISTRIBUICAO_TEMPO_CONSULTA == "exponential":
        return np.random.exponential(TEMPO_MEDIO_CONSULTA)
    elif DISTRIBUICAO_TEMPO_CONSULTA == "normal":
        return max(0, np.random.normal(TEMPO_MEDIO_CONSULTA, 5)) # max(0,...) - garante que não é negativo
    elif DISTRIBUICAO_TEMPO_CONSULTA == "uniform":
        return np.random.uniform(TEMPO_MEDIO_CONSULTA * 0.5, TEMPO_MEDIO_CONSULTA * 1.5)

# Funções auxiliares
# Procura o primeiro médico livre
def procuraMedico(lista): # variavel que começa vazia e vai devolver o medico encontrado
    res = None
    i = 0
    encontrado = False
    while not encontrado and i < len(lista):
        if not lista[i][1]:
            res = lista[i]
            encontrado = True
        i= i + 1
    return res

# FUNÇÃO DE SIMULAÇÃO PARA A INTERFACE
def simula_interface(params):
    # Variável para acumular as mensagens do log
    #log_texto = ""

    # Parâmetros da interface
    NUM_ENFERMEIROS = params['NUM_ENFERMEIROS']
    NUM_MEDICOS = params['NUM_MEDICOS']
    TAXA_CHEGADA = params['TAXA_CHEGADA'] / 60
    TEMPO_MEDIO_TRIAGEM = params['TEMPO_MEDIO_TRIAGEM']
    TEMPO_MEDIO_CONSULTA = params['TEMPO_MEDIO_CONSULTA']
    TEMPO_SIMULACAO = params['TEMPO_SIMULACAO']
    DISTRIBUICAO_TEMPO_CONSULTA = params['DISTRIBUICAO']

    # Definição das strings que representam os tipos de eventos
    CHEGADA = "chegada"
    FIM_TRIAGEM = "fim_triagem"
    SAIDA = "saída"

    # Carrega os dados dos doentes
    with open("pessoas.json", "r", encoding="utf-8") as f:      # ler o ficheiro original
        pessoas_dataset = json.load(f)

    doentes = {}
    tempo_atual = 0.0
    contadorDoentes = 0 # Começar em 0 para usar como índice do dataset
    queueEventos = [] # Fila de eventos futuros, ordenada por tempo de ocorrência do evento
    fila_triagem=[] # fila de doentes a espera de triagem
    queue = [] # Fila de espera dos médicos - doentes à espera de médico disponível
    
    # Listas para recolha de dados para calculo de métricas
    tempos_espera = []
    tempos_consulta_real = []
    tempos_na_clinica = []
    tamanhos_fila_med = []

    # Geração da lista de enfermeiros
    enfermeiros=[]
    for i in range (NUM_ENFERMEIROS):
        enfermeiros.append([f"e{i+1}", False, None, 0.0, 0.0]) 
        # [id, ocupado, doente_corrente, total_tempo_ocupado, inicio_ultima_triagem]    

    # Geração da lista de médicos
    medicos = []
    for i in range(NUM_MEDICOS):
        if i < len(especialidades):
            esp = especialidades[i]
        else:
            # Se houver mais médicos que especialidades, atribui aleatoriamente
            esp = random.choices(especialidades, weights=pesos_medicos, k=1)[0]
        # [id, ocupado, doente_corrente, total_tempo_ocupado, inicio_ultima_consulta, Especialidade]
        medicos.append([f"m{i+1}", False, None, 0.0, 0.0, esp])

    # Mostrar as especialidades dos médicos
    print("-" * 40)
    print(f"{'Médico':<10} | {'Especialidade':<20}")
    print("-" * 40)
    for medico in medicos:
        print(f"{m_id(medico):<10} | {m_especialidade(medico):<20}")
    print("-" * 40)
    print("\n")

    # Cabeçalho da tabela de eventos
    print("-" * 125)
    print(f"{'Evento':<12} | {'Tempo':<8} | {'Doente':<40} | {'Detalhes':<55}")
    print("-" * 125)

    # Dicionário para registar qual médico atendeu cada doente
    atendimentos = {}  # {doente_id: medico_id}

    prioridades_cores = {"vermelha": 1, "amarela": 2, "verde": 3}

    # Listas para os gráficos
    h_t, h_f_tri, h_f_med, h_oc_med, h_oc_enf = [], [], [], [], []

    # Geração das chegadas de doentes
    tempo_atual = tempo_atual + gera_intervalo_tempo_chegada(TAXA_CHEGADA)
    while tempo_atual < TEMPO_SIMULACAO and contadorDoentes < len(pessoas_dataset):
        pessoa_real = pessoas_dataset[contadorDoentes] # entrada controlada de doentes
        doente_id = pessoa_real["id"]
        doentes[doente_id] = pessoa_real
        doentes[doente_id]["chegada"] = tempo_atual # regista o tempo de chegada
        
        # Adiciona o evento de chegada à fila de eventos
        queueEventos = enqueue(queueEventos, (tempo_atual, CHEGADA, doente_id))
        
        contadorDoentes += 1
        tempo_atual = tempo_atual + gera_intervalo_tempo_chegada(TAXA_CHEGADA)

    # Tratamento dos eventos
    doentes_atendidos = 0

    while queueEventos != []:
        # Retira o próximo evento cronológico da fila
        evento, queueEventos = dequeue(queueEventos)
        tempo_atual = e_tempo(evento)

        # Captura de dados para gráficos
        h_t.append(tempo_atual)
        h_f_tri.append(len(fila_triagem))
        h_f_med.append(len(queue))
        tamanhos_fila_med.append(len(queue))
        h_oc_med.append((sum(1 for m in medicos if m[1]) / NUM_MEDICOS) * 100 if NUM_MEDICOS > 0 else 0)
        h_oc_enf.append((sum(1 for e in enfermeiros if e[1]) / NUM_ENFERMEIROS) * 100 if NUM_ENFERMEIROS > 0 else 0)

        # Processa o evento com base no seu tipo
        if e_tipo(evento) == CHEGADA:
            doente_id = e_doente(evento)
            nome_completo = f"{doente_id} - {doentes[doente_id]['nome']}"[:40]
            
            print(f"{'CHEGADA':<12} | {e_tempo(evento):<8.2f} | {nome_completo:<40} | {'Entrou na clínica':<55}")

            # Procura um enfermeiro livre (aquele que esteve menos tempo ocupado)
            enf_index = -1
            min_tempo_ocupado = 999999
            
            i = 0
            while i < len(enfermeiros):
                if not enf_ocupado(enfermeiros[i]):
                    tempo_ocupado = enf_total_tempo_ocupado(enfermeiros[i])
                    if tempo_ocupado < min_tempo_ocupado:
                        min_tempo_ocupado = tempo_ocupado
                        enf_index = i
                i = i + 1
            
            if enf_index != -1:
                # Se encontrou um enfermeiro, inicia a triagem
                enfermeiros[enf_index] = enfOcupa(enfermeiros[enf_index])
                enfermeiros[enf_index] = enfDoenteCorrente(enfermeiros[enf_index], doente_id)
                enfermeiros[enf_index] = enfInicioTriagem(enfermeiros[enf_index], tempo_atual)

                t_triagem = gera_tempo_triagem(TEMPO_MEDIO_TRIAGEM)
                # Agenda o evento de fim de triagem
                queueEventos = enqueue(queueEventos, (tempo_atual + t_triagem, FIM_TRIAGEM, doente_id))
                print(f"{'TRIAGEM':<12} | {tempo_atual:<8.2f} | {nome_completo:<40} | {f'Iniciou triagem com {enf_id(enfermeiros[enf_index])}':<55}")
            else:
                # Se não há enfermeiros livres, o doente vai para a fila de espera da triagem
                fila_triagem.append((doente_id, tempo_atual))
                print(f"{'ESPERA':<12} | {tempo_atual:<8.2f} | {nome_completo:<40} | {f'Aguarda triagem (Fila: {len(fila_triagem)})':<55}")
        
        elif e_tipo(evento) == FIM_TRIAGEM:
            doente_id = e_doente(evento)
            nome_completo = f"{doente_id} - {doentes[doente_id]['nome']}"[:40]
            print(f"{'FIM TRIAGEM':<12} | {e_tempo(evento):<8.2f} | {nome_completo:<40} | {'Terminou triagem':<55}")

            # Encontra o enfermeiro que terminou a triagem e liberta-o
            i = 0
            encontrado = False
            enf_index = -1
            while i < len(enfermeiros) and not encontrado:
                if enf_doente_corrente(enfermeiros[i]) == doente_id:
                    enf_index = i
                    enfermeiros[i] = enfOcupa(enfermeiros[i])
                    enfermeiros[i] = enfDoenteCorrente(enfermeiros[i], None)
                    enfermeiros[i] = enfTempoOcupado(enfermeiros[i], enf_total_tempo_ocupado(enfermeiros[i]) + tempo_atual - enf_inicio_ultima_triagem(enfermeiros[i]))
                    encontrado=True

                    if fila_triagem != []:
                        prox_id, t_cheg = fila_triagem.pop(0)
                        enfermeiros[i] = enfOcupa(enfermeiros[i])
                        enfermeiros[i] = enfDoenteCorrente(enfermeiros[i], prox_id)
                        enfermeiros[i] = enfInicioTriagem(enfermeiros[i], tempo_atual)
                        t_tri = gera_tempo_triagem(TEMPO_MEDIO_TRIAGEM)
                        queueEventos = enqueue(queueEventos, (tempo_atual + t_tri, FIM_TRIAGEM, prox_id))
                    encontrado = True
                i = i + 1
            
            # Atribui pulseira e especialidade ao doente
            doentes[doente_id]["pulseira"] = atribuir_pulseira()
            doentes[doente_id]["especialidade"] = atribuir_especialidade()
            prio_nome = doentes[doente_id]["pulseira"]
            esp_nome = doentes[doente_id]["especialidade"]

            print(f"{'TRIADO':<12} | {tempo_atual:<8.2f} | {nome_completo:<40} | {f'Triado: {prio_nome} | {esp_nome}':<55}")

            # Se o enfermeiro ficou livre e há alguém na fila de triagem, atende o próximo
            if enf_index != -1 and fila_triagem != []:
                prox_doente_id, t_chegada_fila = fila_triagem.pop(0)
                prox_nome_completo = f"{prox_doente_id} - {doentes[prox_doente_id]['nome']}"[:40]
                enfermeiros[enf_index] = enfOcupa(enfermeiros[enf_index])
                enfermeiros[enf_index] = enfDoenteCorrente(enfermeiros[enf_index], prox_doente_id)
                enfermeiros[enf_index] = enfInicioTriagem(enfermeiros[enf_index], tempo_atual)
                t_triagem = gera_tempo_triagem(TEMPO_MEDIO_TRIAGEM)
                queueEventos = enqueue(queueEventos, (tempo_atual + t_triagem, FIM_TRIAGEM, prox_doente_id))
                print(f"{'FILA TRI':<12} | {tempo_atual:<8.2f} | {prox_nome_completo:<40} | {f'Triagem da fila com {enf_id(enfermeiros[enf_index])}':<55}") 

            # Procura um médico livre com a especialidade necessária
            atendido = False
            pessoa = doentes[doente_id]

            for i in range(len(medicos)):
                medico = medicos[i]

                if (medico[1] == False and medico[5] == pessoa['especialidade'] and not atendido):
                    # Se encontrou, inicia a consulta
                    medicos[i] = mOcupa(medico)
                    medicos[i] = mInicioConsulta(medicos[i], tempo_atual)
                    medicos[i] = mDoenteCorrente(medicos[i], doente_id)
                    atendimentos[doente_id] = m_id(medico)
                    
                    # Métrica de espera
                    tempos_espera.append(tempo_atual - doentes[doente_id]["chegada"])

                    tempo_consulta = gera_tempo_consulta(DISTRIBUICAO_TEMPO_CONSULTA, TEMPO_MEDIO_CONSULTA)
                    # Métrica de consulta
                    tempos_consulta_real.append(tempo_consulta)

                    # Agenda o evento de saída
                    queueEventos = enqueue(queueEventos, (tempo_atual + tempo_consulta, SAIDA, doente_id))
                    atendido = True
                    print(f"{'ATENDIDO':<12} | {tempo_atual:<8.2f} | {nome_completo:<40} | {f'Atendido por {m_id(medico)} ({m_especialidade(medico)})':<55}") 

            if not atendido:
                # Se não encontrou médico, o doente vai para a fila de espera de consulta
                queue.append((doente_id, tempo_atual, pessoa['especialidade']))
                print(f"{'ESPERA':<12} | {tempo_atual:<8.2f} | {nome_completo:<40} | {f'Aguarda médico (Fila: {len(queue)})':<55}")

        elif e_tipo(evento) == SAIDA:
            doente_id = e_doente(evento)
            pessoa = doentes[doente_id]
            nome_completo = f"{doente_id} - {doentes[doente_id]['nome']}"[:40]
            
            # Métrica na clínica - Regista o tempo total que o doente passou na clínica
            tempos_na_clinica.append(tempo_atual - doentes[doente_id]["chegada"])

            # Encontra o médico que estava a atender o doente e liberta-o
            medico_index = -1
            i = 0
            encontrado = False
            while i < len(medicos) and not encontrado:
                if m_doente_corrente(medicos[i]) == doente_id:
                    medico_index = i
                    medicos[i] = mOcupa(medicos[i])
                    medicos[i] = mDoenteCorrente(medicos[i], None)
                    medicos[i] = mTempoOcupado(medicos[i], m_total_tempo_ocupado(medicos[i]) + tempo_atual - m_inicio_ultima_consulta(medicos[i]))
                    encontrado = True
                i = i + 1
            
            print(f"{'SAÍDA':<12} | {e_tempo(evento):<8.2f} | {nome_completo:<40} | {f'Saiu da clínica ({pessoa["especialidade"]})':<55}")
            doentes_atendidos += 1

            if medico_index != -1:
                # Se o médico ficou livre
                medico = medicos[medico_index]
                esp_medico = m_especialidade(medico)
                
                melhor_j = -1 # indice do doente escolhido na fila
                min_prioridade = 999 # guarda a melhor preioridade encontrada
                min_tempo = 999999 # guarda menor tempo de chegada (desempate)
                
                j = 0
                while j < len(queue):
                    d_id, t_chegada, especialidade = queue[j]
                    p_fila = doentes[d_id]
                    
                    if p_fila['especialidade'] == esp_medico:
                        prio = prioridades_cores[p_fila['pulseira']]

                        if prio < min_prioridade or (prio == min_prioridade and t_chegada < min_tempo):
                            min_prioridade = prio
                            min_tempo = t_chegada
                            melhor_j = j
                    j += 1
                
                if melhor_j != -1:
                    prox_id = queue[melhor_j][0]
                    queue = queue[:melhor_j] + queue[melhor_j+1:]
                    
                    medicos[medico_index] = mOcupa(medicos[medico_index])
                    medicos[medico_index] = mInicioConsulta(medicos[medico_index], tempo_atual)
                    medicos[medico_index] = mDoenteCorrente(medicos[medico_index], prox_id)
                    
                    # Métrica de espera
                    tempos_espera.append(tempo_atual - doentes[prox_id]["chegada"])
                    tempo_consulta = gera_tempo_consulta(DISTRIBUICAO_TEMPO_CONSULTA, TEMPO_MEDIO_CONSULTA)
                    # Métrica de consulta
                    tempos_consulta_real.append(tempo_consulta)
                    # Evento de saída
                    queueEventos = enqueue(queueEventos, (tempo_atual + tempo_consulta, SAIDA, prox_id))
                    
                    nome_prox = f"{prox_id} - {doentes[prox_id]['nome']}"[:40]
                    print(f"{'FILA':<12} | {tempo_atual:<8.2f} | {nome_prox:<40} | {f'Atendido da fila por {m_id(medico)} ({doentes[prox_id]['pulseira']})':<55}")

    # Retorna um dicionário com todos os resultados e dados recolhidos
    return {
        'atendidos': doentes_atendidos,
        'medicos': medicos,
        'enfermeiros': enfermeiros,
        'historico': {
            't': h_t, 
            'f_tri': h_f_tri, 
            'f_med': h_f_med, 
            'oc_med': h_oc_med, 
            'oc_enf': h_oc_enf
        },
        'metricas': {
            'espera_media': np.mean(tempos_espera) if tempos_espera else 0,
            'consulta_media': np.mean(tempos_consulta_real) if tempos_consulta_real else 0,
            'clinica_media': np.mean(tempos_na_clinica) if tempos_na_clinica else 0,
            'fila_media': np.mean(tamanhos_fila_med) if tamanhos_fila_med else 0,
            'fila_max': np.max(tamanhos_fila_med) if tamanhos_fila_med else 0
        }
    }

# INTERFACE GRÁFICA   

# #Função principal que cria e gere a interface gráfica e os seus eventos.
def draw_figure(canvas, figure):
    figure_canvas_agg = FigureCanvasTkAgg(figure, canvas) # liga matplotlib ao tkinter
    figure_canvas_agg.draw() # renderiza o grafico
    figure_canvas_agg.get_tk_widget().pack(side='top', fill='both', expand=1) # coloca na interface
    return figure_canvas_agg

def main():
    layout = [
        [sg.Text('SIMULAÇÃO DE CLÍNICA MÉDICA', font=('Arial', 18, 'bold'))],
        [sg.Text('Configurações:', font=('Arial', 12, 'bold'))],
        [sg.Text('Enfermeiros (1-100):'), sg.Input('5', key='ENF', size=(5,1)), sg.Text('Médicos (1-100):'), sg.Input('8', key='MED', size=(5,1))],
        [sg.Text('Taxa Chegada (10-30 pac/h):'), sg.Input('10', key='TAXA', size=(5,1)), sg.Text('Duração (min):'), sg.Input('480', key='DUR', size=(5,1))],
        [sg.Text('Tempo Triagem (min):'), sg.Input('5', key='T_TRI', size=(5,1)), sg.Text('Tempo Consulta (min):'), sg.Input('15', key='T_CONS', size=(5,1))],
        [sg.Text('Distribuição:'), sg.Combo(['exponential', 'normal', 'uniform'], default_value='exponential', key='DIST')],
        [sg.Button('EXECUTAR SIMULAÇÃO', size=(30, 2), button_color=('black', 'lightyellow'), key='EXEC'), sg.Button('SAIR', size=(10, 2))],
        [sg.TabGroup([[
            sg.Tab('Log', [[sg.Multiline(size=(130, 12), key='LOG', font='Courier 10', autoscroll=True, disabled=True)]]),
            sg.Tab('Estatísticas', [[sg.Multiline(size=(130, 12), key='STATS', font='Courier 10', disabled=True)]]),
            sg.Tab('Gráficos', [[sg.Column([
                [sg.Canvas(key='CANVAS_FILA', size=(700, 300))], 
                [sg.Canvas(key='CANVAS_OCUP_ENF', size=(700, 300))], 
                [sg.Canvas(key='CANVAS_OCUP_MED', size=(700, 300))],
                [sg.Canvas(key='CANVAS_SENS', size=(700, 300))]
            ], scrollable=True, vertical_scroll_only=True, size=(850, 500))]])
        ]])]
    ]

    window = sg.Window('Clínica Médica', layout, finalize=True, resizable=True)
    window.maximize()

    # Variáveis para guardar as referências dos canvas dos gráficos, para poderem ser limpos depois
    canvas_fila, canvas_ocup_enf, canvas_ocup_med, canvas_sens = None, None, None, None

    stop = False
    while not stop:
        event, values = window.read()
        
        if event in (sg.WIN_CLOSED, 'SAIR'):
            stop = True
        
        if event == 'EXEC':
            erro_input = False
            try:
                f_enf = float(values['ENF'])
                f_med = float(values['MED'])
                taxa = float(values['TAXA'])
                t_tri = float(values['T_TRI'])
                t_cons = float(values['T_CONS'])
                duracao = float(values['DUR'])
                
                if not f_enf.is_integer() or not f_med.is_integer() or not taxa.is_integer() or not duracao.is_integer():
                    sg.popup_error("Erro: Enfermeiros, Médicos, Taxa e Duração devem ser números inteiros!", title="Erro de Formato")
                    erro_input = True
                elif any(v < 0 for v in [f_enf, f_med, taxa, t_tri, t_cons, duracao]):
                    sg.popup_error("Erro: Não são permitidos números negativos!", title="Erro de Validação")
                    erro_input = True
                elif not (10 <= taxa <= 30):
                    sg.popup_error("Erro: A Taxa de Chegada deve estar entre 10 e 30 pac/h!", title="Erro de Validação")
                    erro_input = True
                elif f_enf > 100 or f_med > 100:
                    sg.popup_error("Erro: O limite máximo de profissionais (Enfermeiros/Médicos) é 100!", title="Erro de Validação")
                    erro_input = True
                elif duracao>1440:
                    sg.popup_error("Erro: O limite de tempo da simulação é 24 horas (1440 minutos).", title="Erro de Validação")
                    erro_input = True
                elif t_tri>duracao:
                    sg.popup_error("Erro: O limite de tempo da triagem não pode ser maior que o tempo de simulação.", title="Erro de Validação")
                    erro_input = True
                elif t_cons>duracao:
                    sg.popup_error("Erro: O limite de tempo da consulta não pode ser maior que o tempo de simulação.", title="Erro de Validação")
                    erro_input = True
                else:
                    num_enf, num_med, num_taxa, num_duracao = int(f_enf), int(f_med), int(taxa), int(duracao)
            except ValueError:
                sg.popup_error("Erro: Por favor, introduza apenas números nos campos de configuração!", title="Erro de Input")
                erro_input = True
            
            if not erro_input:
                params = {
                    'NUM_ENFERMEIROS': num_enf,
                    'NUM_MEDICOS': num_med,
                    'TAXA_CHEGADA': num_taxa,
                    'TEMPO_MEDIO_TRIAGEM': t_tri,
                    'TEMPO_MEDIO_CONSULTA': t_cons,
                    'TEMPO_SIMULACAO': num_duracao,
                    'DISTRIBUICAO': values['DIST']
                }

                # Redireciona o output da consola (print) para uma variável em memória
                old_stdout = sys.stdout
                sys.stdout = io.StringIO()
                
                res = simula_interface(params)
                
                # Captura tudo o que foi impresso na consola durante a simulação
                log_capturado = sys.stdout.getvalue()
                # Restaura o output normal da consola
                sys.stdout = old_stdout
                
                # Atualiza o campo de Log na interface gráfica com o texto capturado
                window['LOG'].update(disabled=False)
                window['LOG'].update(log_capturado)
                window['LOG'].update(disabled=True)
                
                m = res['metricas']
                stats = f"RESULTADOS GERAIS:\n"
                stats += f"  Doentes Atendidos: {res['atendidos']}\n"
                stats += f"  Tempo Médio de Espera: {m['espera_media']:.2f} min\n"
                stats += f"  Tempo Médio de Consulta: {m['consulta_media']:.2f} min\n"
                stats += f"  Tempo Médio na Clínica: {m['clinica_media']:.2f} min\n"
                stats += f"  Fila Médicos (Média): {m['fila_media']:.2f}\n"
                stats += f"  Fila Médicos (Máxima): {m['fila_max']}\n\n"

                stats += "ESTATÍSTICAS ENFERMEIROS:\n"
                for e in res['enfermeiros']:
                    # Calcula a taxa de ocupação de cada enfermeiro
                    taxa_oc = (e[3] / params['TEMPO_SIMULACAO']) * 100
                    stats += f"  {e[0]}: Ocupação {taxa_oc:6.2f}%\n"
                
                stats += "\nESTATÍSTICAS MÉDICOS:\n"
                for med in res['medicos']:
                    # Calcula a taxa de ocupação de cada médico
                    taxa_oc = (med[3] / params['TEMPO_SIMULACAO']) * 100
                    stats += f"  {med[0]} ({med[5]:<18}): {taxa_oc:6.2f}%\n"

                # Atualiza o campo de Estatísticas na interface
                window['STATS'].update(disabled=False)
                window['STATS'].update(stats)
                window['STATS'].update(disabled=True)

                # Limpa os gráficos da execução anterior, se existirem
                if canvas_fila: canvas_fila.get_tk_widget().destroy()
                if canvas_ocup_enf: canvas_ocup_enf.get_tk_widget().destroy()
                if canvas_ocup_med: canvas_ocup_med.get_tk_widget().destroy()
                if canvas_sens: canvas_sens.get_tk_widget().destroy()

                # Cria e desenha o gráfico da evolução das filas de espera
                fig1, ax1 = plt.subplots(figsize=(8, 4))
                ax1.plot(res['historico']['t'], res['historico']['f_tri'], label='Fila Triagem', color='darkturquoise')
                ax1.plot(res['historico']['t'], res['historico']['f_med'], label='Fila Médicos', color='hotpink')
                ax1.set_title('Evolução das Filas')
                ax1.legend()
                canvas_fila = draw_figure(window['CANVAS_FILA'].TKCanvas, fig1)

                # Cria e desenha o gráfico da taxa de ocupação dos enfermeiros
                fig2, ax2 = plt.subplots(figsize=(8, 4))
                ax2.plot(res['historico']['t'], res['historico']['oc_enf'], color='mediumpurple')
                ax2.set_title('Taxa de Ocupação dos Enfermeiros (%)')
                ax2.set_ylim(0, 110)
                canvas_ocup_enf = draw_figure(window['CANVAS_OCUP_ENF'].TKCanvas, fig2)

                # Cria e desenha o gráfico da taxa de ocupação dos médicos
                fig3, ax3 = plt.subplots(figsize=(8, 4))
                ax3.plot(res['historico']['t'], res['historico']['oc_med'], color='firebrick')
                ax3.set_title('Taxa de Ocupação dos Médicos (%)')
                ax3.set_ylim(0, 110)
                canvas_ocup_med = draw_figure(window['CANVAS_OCUP_MED'].TKCanvas, fig3)

                # Análise de Sensibilidade: testa o impacto de diferentes taxas de chegada
                taxas_teste = [10, 15, 20, 25, 30]
                filas_medias = []
                for t in taxas_teste:
                    p_teste = params.copy()
                    p_teste['TAXA_CHEGADA'] = t
                    # Executa simulações silenciosas (sem guardar o log) para obter os resultados
                    sys.stdout = io.StringIO()
                    r_teste = simula_interface(p_teste)
                    sys.stdout = old_stdout
                    filas_medias.append(r_teste['metricas']['fila_media'])
                
                # Cria e desenha o gráfico de barras da análise de sensibilidade
                fig4, ax4 = plt.subplots(figsize=(8, 4))
                ax4.bar([str(t) for t in taxas_teste], filas_medias, color='teal')
                ax4.set_title('Sensibilidade: Fila Média vs Taxa de Chegada')
                ax4.set_xlabel('Taxa de Chegada (pac/h)')
                ax4.set_ylabel('Fila Média')
                canvas_sens = draw_figure(window['CANVAS_SENS'].TKCanvas, fig4)

    window.close()

if __name__ == '__main__':
    main()
